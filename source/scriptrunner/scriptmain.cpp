

#include "ai/ai.h"
#include "loaders.h"
#include "dlg_box.h"
#include "dlg_box.h"
#include "strtmesg.h"
#include "sg.h"
#include "viewcalculation.h"
#include "replay.h"
#include "messagedlg.h"
#include "edmisc.h"

#include "researchexecution.h"
#include "resourcenet.h"
#include "mapimageexport.h"
#include "soundList.h"
#include "turncontrol.h"
#include "applicationstarter.h"

#include "stdio-errorhandler.h"

#include "autotraining.h"
#include "lua/luarunner.h"
#include "lua/luastate.h"

void viewcomp( Player& player )
{
   computeview( player.getParentMap() );
}

bool loadGameFromFile( const ASCString& filename )
{
   return false;
}


int runScript( const ASCString& file ) {
   if ( file.size() ) {
      LuaState state;
      LuaRunner runner( state );
      runner.runFile( file );
      if ( !runner.getErrors().empty() )
         errorMessage( runner.getErrors() );
      return 0;
   } else {
      errorMessage("No script provided! Use the -l option");
      return 1;
   }
}


int initAndRunScripts ( const ASCString& file )
{
   loadpalette();

   virtualscreenbuf.init();

   try {
      loadEditordata();
   }
   catch ( ParsingError& err ) {
      errorMessage ( "Error parsing text file " + err.getMessage() );
      return -1;
   }
   catch ( tfileerror& err ) {
      errorMessage ( "Error loading file " + err.getFileName() );
      return -1;
   }
   catch ( ASCexception& ) {
      errorMessage ( "loading of game failed" );
      return -1;
   }
   catch ( ThreadExitException& ) {
      displayLogMessage(0, "caught thread exiting exception, shutting down");
      return -1;
   }

#ifndef _WIN32_
   // Windows/MSVC will catch access violations with this, which we don't want to, because it makes our dump files useless.
   catch ( ... ) {
      fatalError ( "caught undefined exception" );
      return -1;
   }
#endif

   GameMap::sigPlayerTurnEndsStatic.connect( sigc::ptr_fun( &automaticTrainig ));
   //ActionContainer::postActionExecution.connect( SigC::slot( &checkGameEvents ));

   suppressMapTriggerExecution = false;

   return runScript( file );
}


// including the command line parser, which is generated by genparse
#include "clparser/asc.cpp"


void executeUserAction ( tuseractions action ) {};
void execUserAction_ev ( tuseractions action ) {};


int main(int argc, char *argv[] )
{
   assert ( sizeof(PointerSizedInt) == sizeof(int*));

   // we should think about replacing clparser with libpopt
   Cmdline* cl = NULL;
   try {
      cl = new Cmdline ( argc, argv );
   } catch ( const string& s ) {
      cerr << s;
      exit(1);
   }
   auto_ptr<Cmdline> apcl ( cl );

   if ( cl->v() ) {
      ASCString msg = getstartupmessage();
      printf( "%s", msg.c_str() );
      exit(0);
   }

   MessagingHub::Instance().setVerbosity( cl->r() );
   StdIoErrorHandler stdIoErrorHandler(false);
   MessagingHub::Instance().exitHandler.connect( sigc::bind( &exit_asc, -1 ));

#ifdef WIN32
   Win32IoErrorHandler* win32ErrorDialogGenerator = new Win32IoErrorHandler;
#endif

   ConfigurationFileLocator::Instance().setExecutableLocation( argv[0] );
   initFileIO( cl->c() );  // passing the filename from the command line options

   PG_FileArchive archive( argv[0] );

   try {
      int result = initAndRunScripts(cl->l());
      if ( result != 0 )
         return result;
   }
   catch ( bad_alloc& ) {
      fatalError ("Out of memory");
      return 1;
   }
   catch ( ASCmsgException& e ) {
      cerr << e.getMessage() << "\n";
      return 2;
   }
   catch ( ActionResult& ar ) {
      cerr << "ActionResult failed:" << ar.getCode() << " : " << ar.getMessage() << "\n";
      return 2;
   }
   catch ( ... ) {
      cerr << "caught exception\n";
      return 2;  
   }

   cout << "script(s) completed successfully \n";
   return 0;
}
