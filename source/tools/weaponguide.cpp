/*
    This file is part of Advanced Strategic Command; http://www.asc-hq.de
    Copyright (C) 1994-2001  Martin Bickel, Marc Schellenberger and
    Steffen Froehlich
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; see the file COPYING. If not, write to the 
    Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
    Boston, MA  02111-1307  USA
*/
// Version v2.0 , change also GENERAL


#include <stdio.h>
#include <stdlib.h>
#include <algorithm>

#include "../tpascal.inc"
#include "../typen.h"
#include "../basestrm.h"
#include "../misc.h"
#include "../sgstream.h"
#include "../buildingtype.h"
#include "../vehicletype.h"
#include "../errors.h"
#include "../graphicset.h"
#include "../ascstring.h"
#include "../itemrepository.h"
#include "../strtmesg.h"
#include "../basegfx.h"
#include "../loadpcx.h"

#include "infopage.h"
#include "guidegenerator.h"

#ifdef WIN32
#undef main
#endif


// including the command line parser, which is generated by genparse
#include "../clparser/weaponguide.cpp"



const char* tableParam = " class=\"wg\" border=\"1\" ";

FILE* createFile ( const ASCString& filename ) {
  return fopen ( filename.c_str(), "w" );
}


void printIndex ( FILE* fp, const ASCString& index, const ASCString& param = "" ) {
  fprintf ( fp, "<tr><th class=\"wg\" %s > %s  </th>" , param.c_str(), index.c_str() );
}

void printValue ( FILE* fp, const ASCString& data, const ASCString& param = "" ) {
  fprintf( fp, "<td class=\"wg\" %s > %s </td>", param.c_str(), data.c_str() );
}

void printValue ( FILE* fp, int data ) {
  printValue( fp, strrr(data)  );
}


void printLineEnd ( FILE* fp ) {
  fprintf ( fp, "</tr>\n" );
}


void printMainLine ( FILE* fp, const ASCString& index, const ASCString& value ) {
  printIndex ( fp, index );
  printValue( fp, value );
  printLineEnd ( fp );
}

void printMainLine ( FILE* fp, const ASCString& index, int value ) {
  printMainLine ( fp, index, strrr ( value ));
}


ASCString getHeightImgString( int height ) {
  ASCString s;
  for ( int j = 0; j < 8 ; j++ )
    if ( height & ( 1 << j)) {
      ASCString s2;
      s2.format("<img src=\"../hoehe%d.gif\" alt=\"%s\"><br>",j, choehenstufen[j]);
      s += s2;
    }
  return s;
}

const int maxFileSize = 10000000;
char s[maxFileSize];
char d[maxFileSize];

/*
void copyFile( const ASCString& src, const ASCString& dst ) {
  FILE* i = fopen ( src.c_str(), filereadmode );
  FILE* o = fopen ( dst.c_str(), filereadmode );
  bool copy = false;

  if ( !i )
    fatalError ("copyFile :: Could not open input file " + src);

  if ( !o ) {
    copy = true;
    fclose ( i );
  } else {

    int s1 = fread ( s, 1, maxFileSize, i );
    int s2 = fread ( d, 1, maxFileSize, o );
    if ( s1 != s2 )
      copy = true;
    else {
      for ( int i = 0; i < s1; i++ )
        if ( s[i] != d[i] ) {
          copy = true;
          break;
        }
    }
    fclose( o );
    fclose( i );
  }
  if ( copy ) {
    i = fopen ( src.c_str(), filereadmode );
    o = fopen ( dst.c_str(), filewritemode );
    int s1 = fread ( s, 1, maxFileSize, i );
    fwrite ( s, 1, s1, o );
    fclose( o );
    fclose( i );
    printf("*");
  }
  remove ( src.c_str() );
}
*/
int main(int argc, char *argv[] ) {
  Cmdline cl ( argc, argv );

  if ( cl.v() ) {
    cout << argv[0] << " " << getVersionString() << endl;
    exit(0);
  }
  cout << "*******Starting guide generation*******" << endl;
  verbosity = cl.r();

  initFileIO( cl.c(), 4 );  // passing the filename from the command line options
  ASCString prefixDir = cl.d();
  if ( !prefixDir.empty() )
    appendbackslash ( prefixDir );

#ifdef _WIN32_
  ASCString tempPath = getenv("temp");
  appendbackslash(tempPath);
#else
  ASCString tempPath = "/tmp/";
#endif


  printf("Loading data for generating unit documentation. Please wait...");
  loadpalette();
  printf(".");
  loadbi3graphics();
  printf(".");

  loadAllData( false );
  printf(".");
  loadUnitSets();
  printf(".");


  char* wildcard;

  if ( cl.next_param() < argc ) {
    wildcard = argv[cl.next_param()];
    // if a command line parameter is specified, use it as wildcard
    // for example: weaponguide s*.veh
  } else {
    wildcard =  "*";
    // else use all verhicles
  }
  if(true) {
    ASCString uploadDir = prefixDir + UPLOADDIR;
    ASCString command;
#ifdef _WIN32_
    command = "md " + uploadDir;
    system(command.c_str());
    command = "attrib -R " +uploadDir;    
#else
    command = "mkdir " + uploadDir;
    system(command.c_str());
    command = "chmod 750 " +uploadDir;    
#endif
  system(command.c_str());
  }

  
  BuildingGuideGen gen(prefixDir, cl.m(), cl.s(), cl.i(), false, true);
  gen.processSubjects();
  cout << "*******Buildings done*******" << endl; 
  UnitGuideGen unitGen(prefixDir, cl.m(), cl.s(), cl.i(), true, false);
  unitGen.processSubjects();
  cout << "*******Units done*******" << endl;  
  if(true) {
    ASCString uploadDir = prefixDir + UPLOADDIR;
    ASCString command;
#ifdef _WIN32_
    system(command.c_str());
    command = "attrib +R " +uploadDir;    
#else    
    command = "chmod 550 " +uploadDir;    
#endif
  system(command.c_str());
  }

  cout << "******Guide generated*******" << endl;
  return 0;
};





